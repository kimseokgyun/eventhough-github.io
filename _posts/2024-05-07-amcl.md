---
layout: post
title: AMCL
date: 2024-05-07 19:00 +0900
last_modified_at: 2024-05-07 19:00 +0900
tags: [Robot, ROS2]
toc:  true
---
## Conclusion

Particle filter를 이용한 MCL 알고리즘에서 특징점의 양상 따라 Adaptive 계수를 통해 particle을 random 하게 생성하여 Kidnap Problem 에 좀더 강인한 알고리즘이 AMCL 이다.

- MCL은 베이지안필터에서 bel(x)를 Particle로 표현한 알고리즘
- Short-term ,Long-term Average 변수를 통해  기존 Particle Filter 로는 로봇의 실제 위치에 절대 수렴하지 못하는 경우에도 Particle 을 랜덤하게 샘플링하여 복구할수있는 여지가 있다. 
- KLD-Sampling 기법을 통해 Particle 의 개수를 유동적으로 변경하여 Computing resource 낭비를 줄임
- 코드 구현시 KD Tree 자료구조를 이용하여 Particle Cluster 진행한다. 해당 Clustering 작업을통해 최종 추정위치에 따른 공분산 값도 얻는다.
- Lidar Callback Thread에서 AMCL를 돌게끔 구현하여, 알고리즘 flow에 꼬임을 방지.  Lidar는 높아봤자 20~50Hz
## Meaning

- Kalman Filter 보다 
- 

<!-- ![placeholder](http://placehold.it/800x400 "Large example image") -->

## Concept
<inv>ROS2 Humble Version 의 nav2_amcl 기반으로 amcl 이론을 코드로 어떻게 구현했는지 참고했습니다</inv>

### 노드 구성

![placeholder](/upload_image/amcl/amcl_1.png "Large example image"){: .align-center}

<center>nav2_amcl node 는 Lidar Callback Thread, 기본 Node Thread 두개의 Thread로 구성된다</center>

- Lidar Callback Thread 
  - Lidar Subscription Callback 마다 AMCL 알고리즘이 수행된다. 

- Node Thread 
  - Map Sub, Global Localization Service, NoMotion Service, Dynamic Parameter Callback 수행.


### AMCL 구현
![placeholder](/upload_image/amcl/amcl_2.png "Large example image")

![placeholder](/upload_image/amcl/amcl_3.png "Large example image")

#### <center>Initialize Particle </center>

- 각 Particle 초기위치를 선정한다. 초기위치 Pose를 선정하고 Covariance 로 Particle 을 뿌려준다

{% highlight c++ %}
// handleInitialPose in amcle_node.cpp

  // Re-initialize the filter
  pf_vector_t pf_init_pose_mean = pf_vector_zero();
  pf_init_pose_mean.v[0] = pose_new.getOrigin().x(); 
  pf_init_pose_mean.v[1] = pose_new.getOrigin().y();
  pf_init_pose_mean.v[2] = tf2::getYaw(pose_new.getRotation());
  // Copy in the covariance, converting from 6-D to 3-D
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 2; j++) {
      pf_init_pose_cov.m[i][j] = msg.pose.covariance[6 * i + j];
    }
  }

  pf_init_pose_cov.m[2][2] = msg.pose.covariance[6 * 5 + 5];
{% endhighlight %}

  - map 과 odom 의 tf를 만들어주고 pf(particle Filter)를 Init한다
  - odom Frame에서의 pose 의 covariance를 particle Filter의 분산으로 사용한다. 
<br/><br/>


{% highlight c++ %}
// in pf.hpp
typedef struct _pf_t
{
  // This min and max number of samples
  int min_samples, max_samples;

  // Population size parameters
  double pop_err, pop_z;

  // The sample sets.  We keep two sets and use [current_set]
  // to identify the active set.
  int current_set;
  pf_sample_set_t sets[2];

  // Running averages, slow and fast, of likelihood
  double w_slow, w_fast;

  // Decay rates for running averages
  double alpha_slow, alpha_fast;

  // Function used to draw random pose samples
  pf_init_model_fn_t random_pose_fn;
  void * random_pose_data;

  double dist_threshold;  // distance threshold in each axis over which the pf is considered to not
                          // be converged
  int converged;
} pf_t;
{% endhighlight %}

  - pf_t라는 구조체로 particle Filter 를 관리한다.
  - 하나의 파티클필터에 **w_slow**, **w_fast** 파라미터와 **alpha_slow**, **alpha_fast** Adaptive 계수를 관리한다
  - pf_sample_set_t 을 set[2] : 2개의 배열로 구현하여 두개의 particle Filter Sample군을 통해 이전정보와 현재 정보의 Particle을 개별 관리한다.

<br/><br/>
#### <center> Sample Motion Model </center>
math: true

- 의사코드의 **sample_motion_model** 에 해당한다. 입력  \\\(u_t\\\) 에 따른  \\\(x_(t-1)\\\) 을 Simulate한다.

-

math : false


#### <center> Measurement Model </center>

#### <center> Resample Particle </center>